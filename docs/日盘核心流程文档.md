# 日盘核心全流程文档

## 一、业务流程概览

### 1.1 业务目标
- **目的**：周期性盘点高净值商品（手机、平板等），确保库存准确性
- **周期**：7天一个完整周期，确保所有SKU都被盘点
- **时间限制**：每天目标20分钟，最大30分钟
- **任务生成**：每日04:00自动生成，次日03:59截止

### 1.2 业务角色
- **门店店长/店员**：执行盘点操作
- **业务管理员**：配置品类、创建计划
- **系统**：自动生成任务、分配SKU、计算差异

---

## 二、完整业务流程

### 阶段一：配置管理（PC后台）

#### 1. 品类配置
**操作人**：业务管理员  
**入口**：盘点计划管理 → 品类配置

**流程步骤**：
1. 选择日盘品类（仅高净值商品可选）
   - 默认：手机、平板
   - 可选：笔记本、智能手表、耳机等
2. 配置周期参数
   - 周期天数：7天（可调整）
   - 每天目标时间：20分钟
   - 每天最大时间：30分钟
3. 实时校验
   - 系统自动计算：预估SKU数量、预估总时间、可行性比例
   - 风险等级判断：LOW / MEDIUM / HIGH / CRITICAL
   - 如果可行性比例 > 120%，禁止保存配置
4. 保存配置
   - 配置生效后，影响后续所有日盘任务生成

**关键校验规则**：
```
可行性比例 = 预估总时间 / 周期可用时间

≤ 0.8  → LOW（正常）
≤ 1.0  → MEDIUM（需注意）
≤ 1.2  → HIGH（有风险，最后几天需超时）
> 1.2   → CRITICAL（不可行，禁止保存）
```

#### 2. 盘点计划创建（可选）
**操作人**：业务管理员  
**入口**：盘点计划管理 → 新建计划

**流程步骤**：
1. 填写计划信息
   - 计划名称（不可重复）
   - 计划类型：日盘高值商品
   - 盘点月份
   - 盘点开始/结束日期
   - 执行对象（按门店类型/指定门店）
2. 系统验证
   - 周期开始前验证可行性
   - 如果不可行，提示调整配置或延长周期

---

### 阶段二：任务生成（系统自动）

#### 1. 每日04:00自动生成任务

**系统执行流程**：

```
1. 获取当前门店的所有SKU
   ├─ 筛选：仅包含配置的品类（手机、平板等）
   ├─ 状态：未在周期内盘点过的SKU
   └─ 包含：新入库的商品（动态加入）

2. 计算每个SKU的优先级分数
   优先级分数 = f(最后扫描时间, 商品价值, 销量, 新品标识, 历史差异率)
   
   计算公式：
   - 时间因子：距离上次盘点天数（越大优先级越高）
   - 价值因子：商品价格（越高优先级越高）
   - 销量因子：最近销量（越高优先级越高）
   - 新品因子：新商品（优先级最高）
   - 风险因子：历史差异率（越高优先级越高）

3. 按优先级排序，选择当日SKU
   目标：控制在20-30分钟内完成
   
   选择逻辑：
   - 从高优先级开始选择
   - 累计时间 ≤ 目标时间（20分钟）
   - 如果接近上限，允许适当超时（最多30分钟）

4. 决定盘点方式（扫码 vs 填数）
   决策规则：
   - 高价值（≥500元）→ 扫码
   - 有序列号 → 扫码
   - 库存数量大（>50件）→ 混合策略（抽样扫码+批量填数）
   - 其他 → 填数

5. 创建库存快照
   - 记录盘点开始时的库存状态
   - 用于后续差异计算

6. 生成日盘任务
   - 任务ID：PDD{日期}0001
   - 状态：PENDING（待盘点）
   - 截止时间：次日03:59:59
```

#### 2. 新商品入库处理（周期进行中）

**场景**：盘点周期进行中，突然有500件新商品入库

**系统处理流程**：

```
1. 检测到新商品入库
   ├─ 判断：是否在配置的品类范围内
   ├─ 计算：加入当前任务的时间成本
   └─ 评估：对周期完成的影响

2. 智能判断是否加入当前任务
   
   方案四：智能判断 + 分级提示
   
   a) 时间影响 ≤ 5分钟
      → 自动加入当前任务
      → Toast提示："检测到新商品，已自动加入今日任务"
   
   b) 时间影响 5-15分钟
      → 弹窗询问用户
      → 选项："加入今日任务" / "延迟到明天"
      → 用户决策
   
   c) 时间影响 > 15分钟
      → 自动延迟到明天
      → Banner提示："新商品数量较大，已安排到明日任务"

3. 如果加入当前任务
   - 重新计算优先级
   - 动态调整当日SKU列表
   - 更新预估时间
```

---

### 阶段三：盘点执行（移动端）

#### 1. 任务查看与启动

**操作人**：门店店长/店员  
**入口**：移动端 → 门店盘点 → 日盘任务

**流程步骤**：

```
1. 查看任务列表
   ├─ 今日任务：显示待盘点/盘点中状态
   ├─ 历史任务：显示已完成/已过期任务
   └─ 任务信息：任务编号、盘点时间、截止时间

2. 点击"开始盘点"
   ├─ 如果状态为PENDING → 显示"日盘操作说明"弹窗
   │   └─ 弹窗内容：盘点流程、注意事项、操作指引
   └─ 如果状态为IN_PROGRESS → 显示"继续盘点"确认弹窗

3. 确认开始
   └─ 进入盘点扫描页面
```

#### 2. 盘点操作

**操作界面**：两个Tab页
- **未盘点**：显示待盘点的SKU列表
- **已盘点**：显示已完成的SKU列表

**盘点方式一：扫码盘点**

**适用场景**：
- 高价值商品（≥500元）
- 有序列号的商品
- 需要精确追踪的商品

**操作流程**：
```
1. 点击SKU卡片 → 展开该SKU的所有商品列表
2. 扫描商品序列号（IMEI/SN）
3. 系统自动识别：
   ├─ 正常：商品从"未盘点"移到"已盘点"
   ├─ 重复：提示"该商品已扫描"
   └─ 溢余：提示"该商品不在任务列表中"（记录为溢余）
4. 实时保存进度
```

**盘点方式二：填数盘点**

**适用场景**：
- 低价值商品
- 无序列号的商品
- 库存数量大的商品

**操作流程**：
```
1. 点击SKU卡片 → 显示数量输入框
2. 手动输入实际数量
3. 系统自动计算差异
4. 实时保存进度
```

**混合策略（大数量同SKU）**：

**场景**：同一SKU有500件商品

**处理方式**：
```
1. 抽样扫码：扫描100件（验证准确性）
2. 批量填数：剩余400件直接填数
3. 系统合并：将扫码和填数结果合并
4. 时间控制：确保在时间限制内完成
```

#### 3. 进度保存

**自动保存机制**：
- 每次扫描/填数后自动保存
- 使用localStorage本地存储
- 支持断点续传（刷新页面不丢失进度）

#### 4. 完成盘点

**操作流程**：
```
1. 所有SKU盘点完成
2. 点击"完成盘点"按钮
3. 系统确认：
   ├─ 检查是否有未盘点的SKU
   ├─ 提示确认："确定要完成盘点吗？"
   └─ 确认后进入"确认"环节
```

---

### 阶段四：差异确认（移动端）

#### 1. 差异同步

**操作流程**：
```
1. 进入"确认"页面
2. 系统自动检测差异：
   ├─ 短缺：任务中有，但实际未扫描到
   ├─ 溢余：实际扫描到，但任务中没有
   └─ 数量差异：填数盘点中的数量不一致

3. 点击"立即同步"按钮
   ├─ 系统同步盘点期间的销售/退货/调拨记录
   ├─ 动态比对库存变化
   └─ 自动标记withdraw差异
```

#### 2. 差异分类

**差异类型**：

| 类型 | 说明 | 处理方式 |
|------|------|----------|
| **SHORTAGE（短缺）** | 任务中有，实际未找到 | 需要填写原因 |
| **OVERAGE（溢余）** | 实际找到，但任务中没有 | 需要填写原因 |
| **WITHDRAW（撤回）** | 盘点期间已销售/调拨/返仓 | 系统自动标记，无需处理 |

**差异原因**：

**手动填写原因**：
- 损耗（Damage/Loss）
- 清点错误（Counting Error）
- 其他（Other）- 需填写备注

**系统自动检测原因**：
- 销售流水（Sales Flow）
- 店间调拨出库（Transfer Out）
- 店间调拨入库（Transfer In）
- 返仓出库（Return to Warehouse）
- 错发（Wrong Delivery）
- 未入库（Not Received）

#### 3. 差异确认

**操作流程**：
```
1. 查看差异列表（按SKU分组）
   ├─ 显示：SKU名称、图片、价格
   ├─ 统计：短缺数量、溢余数量、withdraw数量
   └─ 状态：待确认 / 已确认

2. 点击差异项 → 进入差异详情页
   ├─ 显示：具体差异商品列表
   ├─ 显示：系统自动检测的原因（如果有）
   └─ 操作：填写原因、上传凭证

3. 填写差异原因
   ├─ 选择原因类型
   ├─ 如果是"其他"，需填写备注
   └─ 可上传凭证图片（可选）

4. 确认差异
   └─ 返回差异列表，该SKU标记为"已确认"

5. 所有差异确认完成后
   └─ "提交"按钮变为可点击状态
```

**自动定位功能**：
- 从差异详情页返回列表时
- 自动滚动到第一个未确认的SKU
- 高亮显示，方便快速定位

---

### 阶段五：签名提交（移动端）

#### 1. 签名确认

**操作流程**：
```
1. 所有差异确认完成后，点击"提交"
2. 进入签名页面
3. 在签名区域签名（手写）
4. 系统保存签名图片（Base64格式）
5. 点击"确认提交"
```

#### 2. 提交完成

**系统处理**：
```
1. 保存盘点结果
   ├─ 任务状态：COMPLETED
   ├─ 完成时间：当前时间
   ├─ 签名信息：签名图片、签名人
   └─ 差异记录：所有差异及原因

2. 更新SKU的最后盘点时间
3. 更新库存快照
4. 生成盘点报告
```

---

## 三、系统流程（技术实现）

### 3.1 数据模型

#### 核心实体

```typescript
// 品类配置
interface CategoryConfig {
  enabledCategories: string[];  // 启用的品类ID
  cycleDays: number;            // 周期天数
  targetTimePerDay: number;     // 每天目标时间（分钟）
  maxTimePerDay: number;         // 每天最大时间（分钟）
}

// 商品
interface Product {
  sku: string;                   // SKU编码
  name: string;                   // 商品名称
  type: ProductType;             // 商品类型
  price: number;                 // 价格
  imei: string;                  // 序列号（如果有）
  lastCounted: string;           // 最后盘点时间
  priority: 'HIGH' | 'MEDIUM' | 'LOW';
  countMethod: 'SCAN' | 'QUANTITY'; // 盘点方式
}

// 盘点任务
interface InventoryTask {
  id: string;                    // 任务ID
  date: string;                  // 任务日期
  items: Product[];              // 任务商品列表（快照）
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';
  scannedImeis: Set<string>;     // 已扫描的序列号
  discrepancies: Discrepancy[];  // 差异列表
  signature?: string;            // 签名（Base64）
  signedBy?: string;             // 签名人
  startTime?: string;            // 开始时间
  endTime?: string;              // 结束时间
}

// 差异
interface Discrepancy {
  imei: string;                  // 序列号
  sku: string;                   // SKU
  name: string;                  // 商品名称
  type: 'OVERAGE' | 'SHORTAGE'; // 差异类型
  price: number;                 // 价格
  reason?: DiscrepancyReason;    // 差异原因
  autoResolved: boolean;         // 是否自动解决
  remarks?: string;              // 备注
  proofImages?: string[];        // 凭证图片
}
```

### 3.2 核心算法

#### 1. SKU选择算法

```python
class DailySKUSelector:
    def __init__(self, cycle_days=7, target_time=20, max_time=25):
        self.cycle_days = cycle_days
        self.target_time = target_time
        self.max_time = max_time
    
    def select_daily_skus(self, store_id, current_date, cycle_start_date):
        """
        选择当日需要盘点的SKU
        """
        # 1. 获取所有未盘点的SKU（包括新入库的）
        all_skus = self.get_uninventoried_skus(store_id, cycle_start_date, current_date)
        
        # 2. 计算每个SKU的优先级分数
        skus_with_priority = []
        for sku in all_skus:
            priority_score = self.calculate_dynamic_priority(sku, current_date)
            skus_with_priority.append((sku, priority_score))
        
        # 3. 按优先级排序
        skus_with_priority.sort(key=lambda x: x[1], reverse=True)
        
        # 4. 选择SKU，控制时间
        selected_skus = []
        total_time = 0
        
        for sku, priority_score in skus_with_priority:
            time_cost = self.estimate_time_cost(sku)
            
            # 如果加入后不超过上限，则加入
            if total_time + time_cost <= self.max_time:
                selected_skus.append(sku)
                total_time += time_cost
            else:
                # 如果接近目标时间，允许适当超时
                if total_time < self.target_time and total_time + time_cost <= self.max_time * 1.1:
                    selected_skus.append(sku)
                    total_time += time_cost
                break
        
        return selected_skus, total_time
    
    def calculate_dynamic_priority(self, sku, current_date):
        """
        计算SKU的动态优先级分数
        """
        # 时间因子：距离上次盘点天数
        days_since_last_scan = (current_date - sku.last_counted).days
        time_factor = min(days_since_last_scan / 7, 1.0) * 0.3
        
        # 价值因子：商品价格
        value_factor = min(sku.price / 10000, 1.0) * 0.25
        
        # 销量因子：最近销量
        sales_factor = min(sku.recent_sales / 100, 1.0) * 0.2
        
        # 新品因子：是否新商品
        new_product_factor = 0.15 if sku.is_new else 0
        
        # 风险因子：历史差异率
        risk_factor = min(sku.historical_variance_rate, 1.0) * 0.1
        
        # 综合分数
        priority_score = (
            time_factor +
            value_factor +
            sales_factor +
            new_product_factor +
            risk_factor
        )
        
        return priority_score
    
    def estimate_time_cost(self, sku):
        """
        估算盘点耗时
        """
        if sku.count_method == 'SCAN':
            # 扫码：每件5秒
            return sku.stock_quantity * 5 / 60  # 转换为分钟
        else:
            # 填数：每件1秒
            return sku.stock_quantity * 1 / 60
```

#### 2. 盘点方式决策算法

```python
def decide_count_method(sku):
    """
    决定盘点方式：扫码 vs 填数
    """
    # 规则1：高价值商品必须扫码
    if sku.price >= 500:
        return 'SCAN'
    
    # 规则2：有序列号的商品必须扫码
    if sku.has_serial_number:
        return 'SCAN'
    
    # 规则3：库存数量大，采用混合策略
    if sku.stock_quantity > 50:
        return 'HYBRID'  # 抽样扫码 + 批量填数
    
    # 规则4：其他情况填数
    return 'QUANTITY'
```

#### 3. 差异计算算法（库存快照 + 动态比对）

```python
def calculate_discrepancies(task, actual_scans, current_date):
    """
    计算差异（考虑盘点期间的库存变化）
    """
    # 1. 获取盘点开始时的库存快照
    snapshot = task.inventory_snapshot  # 任务创建时的库存状态
    
    # 2. 获取盘点期间的库存变化记录
    changes = get_inventory_changes(
        store_id=task.store_id,
        start_time=task.start_time,
        end_time=current_date
    )
    # changes包含：销售、入库、出库、调拨等
    
    # 3. 计算理论库存
    theoretical_inventory = snapshot.copy()
    for change in changes:
        if change.type == 'SALES':
            theoretical_inventory[change.sku] -= change.quantity
        elif change.type == 'INBOUND':
            theoretical_inventory[change.sku] += change.quantity
        elif change.type == 'OUTBOUND':
            theoretical_inventory[change.sku] -= change.quantity
        # ... 其他类型
    
    # 4. 比对实际盘点结果
    discrepancies = []
    
    # 4.1 检查短缺
    for expected_item in task.items:
        if expected_item.imei not in actual_scans:
            # 检查是否在库存变化中
            if is_withdraw(expected_item, changes):
                # 已销售/调拨，标记为withdraw
                discrepancies.append({
                    'type': 'WITHDRAW',
                    'imei': expected_item.imei,
                    'sku': expected_item.sku,
                    'reason': 'SALES_FLOW'  # 或其他原因
                })
            else:
                # 真正的短缺
                discrepancies.append({
                    'type': 'SHORTAGE',
                    'imei': expected_item.imei,
                    'sku': expected_item.sku,
                    'reason': None  # 需要用户填写
                })
    
    # 4.2 检查溢余
    for scanned_imei in actual_scans:
        if scanned_imei not in [item.imei for item in task.items]:
            # 检查是否在库存变化中（新入库）
            if is_new_inbound(scanned_imei, changes):
                # 新入库的商品，标记为withdraw（特殊情况）
                discrepancies.append({
                    'type': 'WITHDRAW',
                    'imei': scanned_imei,
                    'reason': 'NEW_INBOUND'
                })
            else:
                # 真正的溢余
                discrepancies.append({
                    'type': 'OVERAGE',
                    'imei': scanned_imei,
                    'reason': None  # 需要用户填写
                })
    
    return discrepancies
```

#### 4. 周期覆盖保障算法

```python
class CycleCoverageGuarantee:
    """
    周期覆盖保障机制
    确保周期内所有SKU都能被盘点
    """
    
    def ensure_coverage(self, store_id, cycle_start_date, current_date):
        """
        三层保障机制
        """
        # 第一层：周期开始前验证
        if current_date == cycle_start_date:
            feasibility = self.validate_cycle_feasibility(store_id, cycle_start_date)
            if not feasibility['feasible']:
                return self.handle_infeasible_cycle(feasibility)
        
        # 第二层：周期进行中监控
        progress = self.monitor_daily_progress(store_id, cycle_start_date, current_date)
        if progress['risk_level'] in ['HIGH', 'CRITICAL']:
            return self.handle_high_risk(progress)
        
        # 第三层：最后几天兜底
        current_day = (current_date - cycle_start_date).days + 1
        if current_day >= self.cycle_days - 2:
            return self.force_allocate_remaining(store_id, cycle_start_date, current_date)
        
        return {'status': 'NORMAL'}
```

### 3.3 系统交互流程

```
┌─────────────────────────────────────────────────────────────┐
│                     日盘系统交互流程                          │
└─────────────────────────────────────────────────────────────┘

【PC后台】
  配置管理
    ├─ 品类配置 → 保存到数据库
    └─ 计划创建 → 验证可行性

【定时任务（每日04:00）】
  任务生成
    ├─ 获取配置的品类
    ├─ 获取未盘点的SKU
    ├─ 计算优先级
    ├─ 选择当日SKU
    ├─ 决定盘点方式
    ├─ 创建库存快照
    └─ 生成任务 → 推送到移动端

【移动端】
  盘点执行
    ├─ 查看任务列表
    ├─ 开始盘点
    ├─ 扫码/填数
    ├─ 实时保存进度
    └─ 完成盘点

  差异确认
    ├─ 同步库存变化
    ├─ 计算差异
    ├─ 填写原因
    └─ 确认差异

  签名提交
    ├─ 签名
    └─ 提交完成

【后端服务】
  数据处理
    ├─ 更新SKU最后盘点时间
    ├─ 更新库存快照
    ├─ 生成盘点报告
    └─ 触发下一周期任务生成
```

---

## 四、关键时间节点

| 时间点 | 事件 | 说明 |
|--------|------|------|
| **每日04:00** | 任务生成 | 系统自动生成当日日盘任务 |
| **次日03:59** | 任务截止 | 逾期未完成将影响绩效考核 |
| **周期开始前** | 可行性验证 | 验证是否能在周期内完成所有SKU |
| **周期进行中** | 进度监控 | 每天监控进度，提前预警 |
| **最后2天** | 强制分配 | 确保所有重要SKU都被盘点 |

---

## 五、异常处理

### 5.1 新商品入库（周期进行中）

**场景**：盘点周期进行中，突然有大量新商品入库

**处理策略**：
- **时间影响 ≤ 5分钟**：自动加入，Toast提示
- **时间影响 5-15分钟**：弹窗询问用户
- **时间影响 > 15分钟**：自动延迟到明天，Banner提示

### 5.2 周期无法完成

**场景**：按每天上限时间，周期结束时仍有SKU未盘点

**处理策略**：
1. **预防**：配置时校验，禁止不可行配置
2. **监控**：周期进行中实时监控，提前预警
3. **兜底**：
   - 最后几天允许适当超时
   - 优先保证高价值SKU
   - 低优先级SKU延迟到下周期

### 5.3 盘点中断

**场景**：盘点过程中断（网络问题、应用崩溃等）

**处理策略**：
- 本地自动保存进度
- 支持断点续传
- 恢复时显示"继续盘点"提示

---

## 六、数据流转

```
配置数据（PC后台）
    ↓
品类配置表
    ↓
任务生成服务（定时任务）
    ↓
日盘任务表
    ↓
移动端应用
    ↓
盘点结果（本地存储 + 实时同步）
    ↓
差异计算服务
    ↓
差异确认（移动端）
    ↓
签名提交
    ↓
盘点报告（数据库）
    ↓
下一周期任务生成
```

---

## 七、性能指标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| **每日盘点时间** | 20分钟 | 目标时间 |
| **每日最大时间** | 30分钟 | 上限时间 |
| **周期完成率** | 100% | 所有SKU都要被盘点 |
| **差异准确率** | >95% | 通过动态比对减少虚假差异 |
| **任务生成时间** | <1分钟 | 每日04:00生成任务 |

---

## 八、总结

日盘系统通过以下机制确保高效、准确完成盘点：

1. **智能SKU选择**：基于多维度优先级，确保重要商品优先盘点
2. **灵活盘点方式**：根据商品特性自动选择扫码或填数
3. **动态差异计算**：通过库存快照+动态比对，准确识别真实差异
4. **周期覆盖保障**：三层保障机制，确保所有SKU都被盘点
5. **实时进度监控**：提前预警，及时调整策略

整个流程从配置到执行到确认，形成了完整的闭环，既保证了业务需求，又控制了时间成本。
